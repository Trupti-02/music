# -*- coding: utf-8 -*-
"""Spotify_Application.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d6wjN4TUBWGY3ZkQZ9pmnEwApJsPGoOl
"""

# spotifyapp.py
import streamlit as st
import pandas as pd
import numpy as np
import json
from sklearn.preprocessing import StandardScaler
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score, f1_score, roc_auc_score
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier, StackingClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from xgboost import XGBClassifier
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import seaborn as sns

st.set_page_config(page_title="üéµ Spotify AI Recommender", layout="wide")

@st.cache_data(show_spinner=True)
def load_data():
    df = pd.read_csv("spotify_tracks.csv", low_memory=False)
    df = df.drop_duplicates(subset=['track_name', 'track_genre'], keep='first')
    audio_cols = ['danceability', 'energy', 'loudness', 'speechiness', 'acousticness',
                  'instrumentalness', 'liveness', 'tempo', 'duration_ms', 'valence']
    df[audio_cols] = df[audio_cols].fillna(df[audio_cols].mean()).astype(np.float32)

    if 'language' in df.columns:
        df['language'] = df['language'].fillna("unknown").str.strip().str.lower()

    return df, audio_cols

spotify_df, model_features = load_data()

st.sidebar.title("üîç Navigation")
page = st.sidebar.radio("Go to", ["EDA", "Model Evaluation", "Recommend Songs"])

# --------------------------------------
# üìä 1. EDA
# --------------------------------------
if page == "EDA":
    st.title("üìä Spotify Dataset - EDA Dashboard")
    st.write(f"**Total Records:** {spotify_df.shape[0]:,}")
    st.dataframe(spotify_df[model_features].describe(), use_container_width=True)

    st.subheader("üéß Genre Distribution (Top 20)")
    st.bar_chart(spotify_df['track_genre'].value_counts().head(20))

    if 'language' in spotify_df.columns:
        st.subheader("üó£Ô∏è Language Distribution")
        st.bar_chart(spotify_df['language'].value_counts().head(20))

    st.subheader("üìà Correlation Heatmap")
    fig, ax = plt.subplots(figsize=(10, 6))
    sns.heatmap(spotify_df[model_features].corr(), annot=False, cmap='coolwarm', ax=ax)
    st.pyplot(fig)

    st.subheader("üîç Feature Histogram")
    feature = st.selectbox("Choose Feature", model_features)
    fig2, ax2 = plt.subplots()
    sns.histplot(spotify_df[feature], kde=True, ax=ax2, bins=30)
    st.pyplot(fig2)

# --------------------------------------
# ü§ñ 2. Model Evaluation
# --------------------------------------
elif page == "Model Evaluation":
    st.title("ü§ñ Model Evaluation on Valence Prediction")
    X = spotify_df[model_features[:-1]]
    y = (spotify_df['valence'] > 0.5).astype(int)

    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

    models = {
        "KNN": KNeighborsClassifier(n_neighbors=7),
        "Random Forest": RandomForestClassifier(n_estimators=200, max_depth=20),
        "Logistic Regression": LogisticRegression(max_iter=1000),
        "SVM": SVC(C=2, kernel='rbf', probability=True),
        "XGBoost": XGBClassifier(use_label_encoder=False, eval_metric='logloss')
    }

    stacking = StackingClassifier(
        estimators=[(k, m) for k, m in models.items()],
        final_estimator=LogisticRegression()
    )
    models["Stacking Ensemble"] = stacking

    selected = st.multiselect("Select Models to Train", list(models.keys()), default=list(models.keys())[:3])

    for name in selected:
        model = models[name]
        model.fit(X_train, y_train)
        preds = model.predict(X_test)
        st.write(f"### üìå {name} Performance")
        st.text(classification_report(y_test, preds))
        st.write(f"**Accuracy:** {accuracy_score(y_test, preds):.4f} | **F1-score:** {f1_score(y_test, preds):.4f} | **ROC AUC:** {roc_auc_score(y_test, model.predict_proba(X_test)[:,1]):.4f}")

# --------------------------------------
# üéµ 3. Recommend Songs (No Language Filter)
# --------------------------------------
else:
    st.title("üéµ Content-Based Song Recommendation")
    uploaded_file = st.file_uploader("Upload your liked songs playlist (.json)", type="json")

    if uploaded_file:
        playlist_data = json.load(uploaded_file)
        user_df = pd.DataFrame(playlist_data)

        missing_cols = [col for col in model_features[:-1] if col not in user_df.columns]
        if missing_cols:
            st.error(f"The uploaded JSON is missing required feature columns: {missing_cols}")
        else:
            user_df = user_df.dropna(subset=model_features[:-1])
            user_vector = user_df[model_features[:-1]].mean().values.reshape(1, -1)

            st.success("User profile vector computed ‚úÖ")

            filter_type = st.radio("Apply Filter", ["None", "By Genre", "By Mood"])
            filtered_df = spotify_df.copy()

            if filter_type == "By Genre":
                genre = st.selectbox("Genre", sorted(spotify_df['track_genre'].dropna().unique()))
                filtered_df = filtered_df[filtered_df['track_genre'].str.contains(genre, case=False)]

            elif filter_type == "By Mood":
                mood = st.selectbox("Mood", ["Energetic + Happy", "Calm + Low Valence"])
                if mood == "Energetic + Happy":
                    filtered_df = filtered_df[(filtered_df['energy'] > 0.7) & (filtered_df['valence'] > 0.7)]
                else:
                    filtered_df = filtered_df[(filtered_df['energy'] < 0.4) & (filtered_df['valence'] < 0.4)]

            if not filtered_df.empty:
                scaler_local = StandardScaler()
                df_scaled = scaler_local.fit_transform(filtered_df[model_features[:-1]])
                user_scaled = scaler_local.transform(user_vector)
                similarity = cosine_similarity(user_scaled, df_scaled).flatten()
                filtered_df['similarity'] = similarity

                top_k = st.slider("Select number of songs", 5, 50, 10)
                top_songs = filtered_df.sort_values("similarity", ascending=False).head(top_k)
                st.dataframe(top_songs[['track_name', 'track_genre', 'similarity']])
            else:
                st.warning("No songs found for the selected filter.")

if st.checkbox("Show PCA Visualization"):
    st.subheader("üé® PCA Visualization of Songs")
    
    # Fit PCA on entire Spotify dataset
    scaler_all = StandardScaler()
    reduced_all = PCA(n_components=2).fit_transform(scaler_all.fit_transform(spotify_df[model_features[:-1]]))
    pca_df = pd.DataFrame(reduced_all, columns=["PC1", "PC2"])
    pca_df["Valence_Label"] = (spotify_df['valence'] > 0.5).astype(int)
    pca_df["track_name"] = spotify_df["track_name"]
    
    # Mark recommended songs
    top_songs_ids = top_songs.index
    pca_df["Recommended"] = pca_df.index.isin(top_songs_ids)

    fig, ax = plt.subplots(figsize=(10, 6))

    # Plot non-recommended songs
    non_rec = pca_df[~pca_df["Recommended"]]
    scatter = ax.scatter(
        non_rec["PC1"], non_rec["PC2"],
        c=non_rec["Valence_Label"], cmap="coolwarm", label="All Songs", alpha=0.4
    )

    # Plot recommended songs
    rec = pca_df[pca_df["Recommended"]]
    ax.scatter(
        rec["PC1"], rec["PC2"],
        c='gold', edgecolors='black', label="Recommended Songs", s=80, marker='*'
    )

    # Legend and labels
    ax.legend(
        [scatter, ax.collections[1]],
        ["All Songs (Blue = Low Valence, Red = High Valence)", "‚≠ê Recommended Songs"],
        loc="upper right"
    )
    ax.set_title("PCA Projection of Songs (Color = Valence, ‚≠ê = Recommended)")
    ax.set_xlabel("Principal Component 1")
    ax.set_ylabel("Principal Component 2")

    st.pyplot(fig)
